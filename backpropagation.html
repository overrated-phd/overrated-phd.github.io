<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backpropagation: Finding the Optimum on a Loss Landscape</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --text-primary: #e8e8ed;
            --text-secondary: #9898a8;
            --text-muted: #606070;
            --accent-ball: #ff6b6b;
            --accent-path: #4ecdc4;
            --accent-gradient: #a855f7;
            --accent-minimum: #22c55e;
            --accent-arrow: #fbbf24;
            --border-color: #2a2a3a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            height: 100vh;
        }

        /* 3D Canvas */
        #canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(180deg, #0f0f18 0%, #0a0a0f 100%);
        }

        #three-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Overlay Info */
        .info-overlay {
            position: absolute;
            top: 1.5rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .info-badge {
            background: rgba(18, 18, 26, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 0.75rem 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .info-badge-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .icon-loss { background: rgba(255, 107, 107, 0.2); }
        .icon-step { background: rgba(168, 85, 247, 0.2); }
        .icon-pos { background: rgba(78, 205, 196, 0.2); }

        .info-badge-content {
            display: flex;
            flex-direction: column;
        }

        .info-badge-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-badge-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .value-loss { color: var(--accent-ball); }
        .value-step { color: var(--accent-gradient); }
        .value-pos { color: var(--accent-path); }

        /* Drag hint */
        .drag-hint {
            position: absolute;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(18, 18, 26, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 0.6rem 1.25rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .drag-hint.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Control Panel */
        .control-panel {
            width: 340px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .panel-header {
            text-align: center;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-header h1 {
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-gradient) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.25rem;
        }

        .panel-header p {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .panel-section {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 1.25rem;
        }

        .panel-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-title::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent-gradient);
            border-radius: 2px;
        }

        /* Buttons */
        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6rem;
        }

        .btn {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-gradient) 0%, #7c3aed 100%);
            color: white;
            grid-column: span 2;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.35);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            border-color: var(--accent-gradient);
        }

        .btn-danger {
            background: var(--accent-ball);
            color: white;
        }

        /* Slider */
        .slider-group {
            margin-bottom: 1rem;
        }

        .slider-group:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .slider-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-gradient);
            background: var(--bg-secondary);
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
        }

        .slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: var(--bg-secondary);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-gradient);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Function Buttons */
        .func-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .func-btn {
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            padding: 0.6rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .func-btn.active {
            background: var(--accent-gradient);
            border-color: var(--accent-gradient);
            color: white;
        }

        .func-btn:hover:not(.active) {
            border-color: var(--accent-gradient);
            color: var(--text-primary);
        }

        /* History */
        .history-list {
            max-height: 140px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.5rem;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 0.35rem 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-step { color: var(--text-muted); }
        .history-loss { color: var(--accent-ball); }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-line {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 5px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        /* Responsive */
        @media (max-width: 800px) {
            .app-container {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                max-height: 50vh;
            }
            #canvas-container {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- 3D Canvas -->
        <div id="canvas-container">
            <div class="info-overlay">
                <div class="info-badge">
                    <div class="info-badge-icon icon-loss">üìâ</div>
                    <div class="info-badge-content">
                        <span class="info-badge-label">Loss</span>
                        <span class="info-badge-value value-loss" id="lossValue">0.0000</span>
                    </div>
                </div>
                <div class="info-badge">
                    <div class="info-badge-icon icon-step">üîÑ</div>
                    <div class="info-badge-content">
                        <span class="info-badge-label">Step</span>
                        <span class="info-badge-value value-step" id="stepValue">0</span>
                    </div>
                </div>
                <div class="info-badge">
                    <div class="info-badge-icon icon-pos">üìç</div>
                    <div class="info-badge-content">
                        <span class="info-badge-label">Position</span>
                        <span class="info-badge-value value-pos" id="posValue">(0.00, 0.00)</span>
                    </div>
                </div>
            </div>
            
            <div class="drag-hint" id="dragHint">
                <span>üñ±Ô∏è</span> Drag to rotate ‚Ä¢ Scroll to zoom
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="panel-header">
                <h1>Gradient Descent</h1>
                <p>Finding the minimum on a loss landscape</p>
            </div>

            <div class="panel-section">
                <div class="panel-title">Controls</div>
                <div class="btn-grid">
                    <button class="btn btn-primary" id="btnStart" onclick="toggleDescent()">
                        ‚ñ∂ Start
                    </button>
                    <button class="btn btn-secondary" onclick="stepOnce()">
                        ‚Üí Step
                    </button>
                    <button class="btn btn-secondary" onclick="resetSimulation()">
                        ‚Ü∫ Reset
                    </button>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot" style="background: var(--accent-ball);"></div>
                        <span>Current</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line" style="background: var(--accent-path);"></div>
                        <span>Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: var(--accent-minimum);"></div>
                        <span>Minimum</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line" style="background: var(--accent-arrow);"></div>
                        <span>Gradient</span>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Parameters</div>
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Learning Rate (Œ∑)</span>
                        <span class="slider-value" id="lrDisplay">0.10</span>
                    </div>
                    <input type="range" class="slider" id="lrSlider" min="0.01" max="0.5" step="0.01" value="0.1">
                </div>
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Start X</span>
                        <span class="slider-value" id="xDisplay">2.0</span>
                    </div>
                    <input type="range" class="slider" id="xSlider" min="-3" max="3" step="0.1" value="2">
                </div>
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Start Y</span>
                        <span class="slider-value" id="yDisplay">2.0</span>
                    </div>
                    <input type="range" class="slider" id="ySlider" min="-3" max="3" step="0.1" value="2">
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Loss Function</div>
                <div class="func-grid">
                    <button class="func-btn active" data-func="bowl" onclick="setFunction('bowl')">Bowl</button>
                    <button class="func-btn" data-func="rastrigin" onclick="setFunction('rastrigin')">Rastrigin</button>
                    <button class="func-btn" data-func="saddle" onclick="setFunction('saddle')">Saddle</button>
                    <button class="func-btn" data-func="rosenbrock" onclick="setFunction('rosenbrock')">Rosenbrock</button>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">History</div>
                <div class="history-list" id="historyList">
                    <div class="history-item">
                        <span class="history-step">Ready</span>
                        <span class="history-loss">‚Äî</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== Configuration ==========
        const config = {
            learningRate: 0.1,
            startX: 2.0,
            startY: 2.0,
            currentFunc: 'bowl',
            maxSteps: 1000,
            convergenceThreshold: 0.0001
        };

        // ========== Loss Functions ==========
        const functions = {
            bowl: {
                f: (x, y) => x*x + y*y,
                grad: (x, y) => [2*x, 2*y],
                min: [0, 0],
                scale: 0.15
            },
            rastrigin: {
                f: (x, y) => 20 + (x*x - 10*Math.cos(2*Math.PI*x)) + (y*y - 10*Math.cos(2*Math.PI*y)),
                grad: (x, y) => [
                    2*x + 20*Math.PI*Math.sin(2*Math.PI*x),
                    2*y + 20*Math.PI*Math.sin(2*Math.PI*y)
                ],
                min: [0, 0],
                scale: 0.05
            },
            saddle: {
                f: (x, y) => x*x - y*y,
                grad: (x, y) => [2*x, -2*y],
                min: [0, 0],
                scale: 0.15
            },
            rosenbrock: {
                f: (x, y) => Math.pow(1 - x, 2) + 100 * Math.pow(y - x*x, 2),
                grad: (x, y) => [
                    -2*(1 - x) - 400*x*(y - x*x),
                    200*(y - x*x)
                ],
                min: [1, 1],
                scale: 0.01
            }
        };

        // ========== State ==========
        let state = {
            x: config.startX,
            y: config.startY,
            step: 0,
            path: [],
            isRunning: false,
            animationId: null
        };

        // ========== Three.js Setup ==========
        let scene, camera, renderer, controls;
        let surfaceMesh, ballMesh, pathLine, arrowLine, minimumMesh;
        let pathPoints = [];

        function initThree() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            // Camera
            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0x8855ff, 0.3);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);

            // Grid helper
            const gridHelper = new THREE.GridHelper(8, 16, 0x333344, 0x222233);
            gridHelper.position.y = -0.01;
            scene.add(gridHelper);

            // Axes
            const axesGroup = new THREE.Group();
            
            // X axis (red)
            const xAxisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-4, 0, 0),
                new THREE.Vector3(4, 0, 0)
            ]);
            const xAxisMat = new THREE.LineBasicMaterial({ color: 0xff6666, opacity: 0.5, transparent: true });
            axesGroup.add(new THREE.Line(xAxisGeo, xAxisMat));

            // Y axis (green) - pointing up in 3D
            const yAxisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 4, 0)
            ]);
            const yAxisMat = new THREE.LineBasicMaterial({ color: 0x66ff66, opacity: 0.5, transparent: true });
            axesGroup.add(new THREE.Line(yAxisGeo, yAxisMat));

            // Z axis (blue)
            const zAxisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -4),
                new THREE.Vector3(0, 0, 4)
            ]);
            const zAxisMat = new THREE.LineBasicMaterial({ color: 0x6666ff, opacity: 0.5, transparent: true });
            axesGroup.add(new THREE.Line(zAxisGeo, zAxisMat));

            scene.add(axesGroup);

            // Create surface
            createSurface();

            // Ball (current position)
            const ballGeo = new THREE.SphereGeometry(0.15, 32, 32);
            const ballMat = new THREE.MeshStandardMaterial({ 
                color: 0xff6b6b, 
                emissive: 0xff6b6b,
                emissiveIntensity: 0.3
            });
            ballMesh = new THREE.Mesh(ballGeo, ballMat);
            scene.add(ballMesh);

            // Ball glow
            const glowGeo = new THREE.SphereGeometry(0.25, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xff6b6b,
                transparent: true,
                opacity: 0.2
            });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            ballMesh.add(glowMesh);

            // Minimum marker
            const minGeo = new THREE.SphereGeometry(0.12, 32, 32);
            const minMat = new THREE.MeshStandardMaterial({ 
                color: 0x22c55e,
                emissive: 0x22c55e,
                emissiveIntensity: 0.5
            });
            minimumMesh = new THREE.Mesh(minGeo, minMat);
            scene.add(minimumMesh);

            // Path line
            const pathGeo = new THREE.BufferGeometry();
            const pathMat = new THREE.LineBasicMaterial({ 
                color: 0x4ecdc4, 
                linewidth: 2 
            });
            pathLine = new THREE.Line(pathGeo, pathMat);
            scene.add(pathLine);

            // Gradient arrow
            const arrowGeo = new THREE.BufferGeometry();
            const arrowMat = new THREE.LineBasicMaterial({ 
                color: 0xfbbf24, 
                linewidth: 3 
            });
            arrowLine = new THREE.Line(arrowGeo, arrowMat);
            scene.add(arrowLine);

            // Manual orbit controls
            setupControls();

            // Update ball position
            updateBallPosition();
            updateMinimumPosition();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            animate();
        }

        function createSurface() {
            // Remove old surface
            if (surfaceMesh) {
                scene.remove(surfaceMesh);
                surfaceMesh.geometry.dispose();
                surfaceMesh.material.dispose();
            }

            const func = functions[config.currentFunc];
            const size = 8;
            const segments = 80;

            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            const positions = geometry.attributes.position.array;
            const colors = new Float32Array(positions.length);

            let minZ = Infinity, maxZ = -Infinity;

            // First pass: calculate heights and find min/max
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                let z = func.f(x, y) * func.scale;
                z = Math.max(-3, Math.min(3, z)); // Clamp
                positions[i + 2] = z;
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            }

            // Second pass: assign colors
            for (let i = 0; i < positions.length; i += 3) {
                const z = positions[i + 2];
                const t = (z - minZ) / (maxZ - minZ + 0.001);
                
                // Purple to cyan gradient
                const r = 0.4 + t * 0.3;
                const g = 0.2 + t * 0.5;
                const b = 0.6 + t * 0.2;
                
                colors[i] = r;
                colors[i + 1] = g;
                colors[i + 2] = b;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false,
                metalness: 0.1,
                roughness: 0.7,
                transparent: true,
                opacity: 0.9
            });

            surfaceMesh = new THREE.Mesh(geometry, material);
            surfaceMesh.rotation.x = -Math.PI / 2;
            scene.add(surfaceMesh);
        }

        // ========== Manual Orbit Controls ==========
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let spherical = { radius: 12, theta: Math.PI / 4, phi: Math.PI / 3 };

        function setupControls() {
            const container = document.getElementById('canvas-container');

            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
                document.getElementById('dragHint').classList.add('hidden');
            });

            container.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                spherical.theta -= deltaX * 0.01;
                spherical.phi -= deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('mouseup', () => { isDragging = false; });
            container.addEventListener('mouseleave', () => { isDragging = false; });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                spherical.radius += e.deltaY * 0.01;
                spherical.radius = Math.max(5, Math.min(25, spherical.radius));
                updateCameraPosition();
            });

            // Touch support
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    document.getElementById('dragHint').classList.add('hidden');
                }
            });

            container.addEventListener('touchmove', (e) => {
                if (!isDragging || e.touches.length !== 1) return;
                e.preventDefault();

                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                spherical.theta -= deltaX * 0.01;
                spherical.phi -= deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                updateCameraPosition();
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            });

            container.addEventListener('touchend', () => { isDragging = false; });

            updateCameraPosition();
        }

        function updateCameraPosition() {
            camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
            camera.position.y = spherical.radius * Math.cos(spherical.phi);
            camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
            camera.lookAt(0, 0, 0);
        }

        // ========== Ball & Path ==========
        function updateBallPosition() {
            const func = functions[config.currentFunc];
            let z = func.f(state.x, state.y) * func.scale;
            z = Math.max(-3, Math.min(3, z));
            ballMesh.position.set(state.x, z + 0.15, state.y);

            // Update gradient arrow
            const grad = func.grad(state.x, state.y);
            const gradMag = Math.sqrt(grad[0]*grad[0] + grad[1]*grad[1]);
            
            if (gradMag > 0.001) {
                const arrowLen = Math.min(gradMag * 0.2, 1.5);
                const endX = state.x - (grad[0] / gradMag) * arrowLen;
                const endY = state.y - (grad[1] / gradMag) * arrowLen;
                let endZ = func.f(endX, endY) * func.scale;
                endZ = Math.max(-3, Math.min(3, endZ));

                const arrowPoints = [
                    new THREE.Vector3(state.x, z + 0.2, state.y),
                    new THREE.Vector3(endX, endZ + 0.2, endY)
                ];
                arrowLine.geometry.dispose();
                arrowLine.geometry = new THREE.BufferGeometry().setFromPoints(arrowPoints);
            }
        }

        function updateMinimumPosition() {
            const func = functions[config.currentFunc];
            const minPos = func.min;
            let z = func.f(minPos[0], minPos[1]) * func.scale;
            z = Math.max(-3, Math.min(3, z));
            minimumMesh.position.set(minPos[0], z + 0.12, minPos[1]);
        }

        function updatePath() {
            const func = functions[config.currentFunc];
            const points = state.path.map(p => {
                let z = func.f(p.x, p.y) * func.scale;
                z = Math.max(-3, Math.min(3, z));
                return new THREE.Vector3(p.x, z + 0.1, p.y);
            });

            if (points.length > 1) {
                pathLine.geometry.dispose();
                pathLine.geometry = new THREE.BufferGeometry().setFromPoints(points);
            }
        }

        // ========== Gradient Descent ==========
        function gradientStep() {
            const func = functions[config.currentFunc];
            const grad = func.grad(state.x, state.y);

            state.x -= config.learningRate * grad[0];
            state.y -= config.learningRate * grad[1];

            // Clamp
            state.x = Math.max(-4, Math.min(4, state.x));
            state.y = Math.max(-4, Math.min(4, state.y));

            state.step++;
            state.path.push({ x: state.x, y: state.y });

            updateBallPosition();
            updatePath();
            updateDisplay();
            addHistoryItem();

            // Check convergence
            const gradMag = Math.sqrt(grad[0]*grad[0] + grad[1]*grad[1]);
            return gradMag > config.convergenceThreshold && state.step < config.maxSteps;
        }

        function runDescent() {
            if (!state.isRunning) return;

            const shouldContinue = gradientStep();

            if (shouldContinue) {
                state.animationId = setTimeout(runDescent, 80);
            } else {
                stopDescent();
            }
        }

        function toggleDescent() {
            if (state.isRunning) {
                stopDescent();
            } else {
                startDescent();
            }
        }

        function startDescent() {
            state.isRunning = true;
            document.getElementById('btnStart').innerHTML = '‚è∏ Pause';
            document.getElementById('btnStart').classList.remove('btn-primary');
            document.getElementById('btnStart').classList.add('btn-danger');

            if (state.path.length === 0) {
                state.path.push({ x: state.x, y: state.y });
            }

            runDescent();
        }

        function stopDescent() {
            state.isRunning = false;
            if (state.animationId) clearTimeout(state.animationId);
            document.getElementById('btnStart').innerHTML = '‚ñ∂ Continue';
            document.getElementById('btnStart').classList.add('btn-primary');
            document.getElementById('btnStart').classList.remove('btn-danger');
        }

        function stepOnce() {
            if (state.isRunning) stopDescent();
            if (state.path.length === 0) {
                state.path.push({ x: state.x, y: state.y });
            }
            gradientStep();
        }

        function resetSimulation() {
            stopDescent();
            state.x = config.startX;
            state.y = config.startY;
            state.step = 0;
            state.path = [];

            // Clear path geometry
            pathLine.geometry.dispose();
            pathLine.geometry = new THREE.BufferGeometry();

            updateBallPosition();
            updateDisplay();

            document.getElementById('historyList').innerHTML = `
                <div class="history-item">
                    <span class="history-step">Ready</span>
                    <span class="history-loss">‚Äî</span>
                </div>
            `;
            document.getElementById('btnStart').innerHTML = '‚ñ∂ Start';
        }

        function setFunction(funcName) {
            config.currentFunc = funcName;
            document.querySelectorAll('.func-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.func-btn[data-func="${funcName}"]`).classList.add('active');

            createSurface();
            updateMinimumPosition();
            resetSimulation();
        }

        // ========== UI Updates ==========
        function updateDisplay() {
            const func = functions[config.currentFunc];
            const loss = func.f(state.x, state.y);

            document.getElementById('lossValue').textContent = loss.toFixed(4);
            document.getElementById('stepValue').textContent = state.step;
            document.getElementById('posValue').textContent = `(${state.x.toFixed(2)}, ${state.y.toFixed(2)})`;
        }

        function addHistoryItem() {
            const container = document.getElementById('historyList');
            const func = functions[config.currentFunc];
            const loss = func.f(state.x, state.y);

            const item = document.createElement('div');
            item.className = 'history-item';
            item.innerHTML = `
                <span class="history-step">Step ${state.step}</span>
                <span class="history-loss">${loss.toFixed(4)}</span>
            `;

            container.insertBefore(item, container.firstChild);

            while (container.children.length > 30) {
                container.removeChild(container.lastChild);
            }
        }

        // ========== Event Listeners ==========
        document.getElementById('lrSlider').addEventListener('input', (e) => {
            config.learningRate = parseFloat(e.target.value);
            document.getElementById('lrDisplay').textContent = config.learningRate.toFixed(2);
        });

        document.getElementById('xSlider').addEventListener('input', (e) => {
            config.startX = parseFloat(e.target.value);
            document.getElementById('xDisplay').textContent = config.startX.toFixed(1);
            if (!state.isRunning && state.path.length === 0) {
                state.x = config.startX;
                updateBallPosition();
                updateDisplay();
            }
        });

        document.getElementById('ySlider').addEventListener('input', (e) => {
            config.startY = parseFloat(e.target.value);
            document.getElementById('yDisplay').textContent = config.startY.toFixed(1);
            if (!state.isRunning && state.path.length === 0) {
                state.y = config.startY;
                updateBallPosition();
                updateDisplay();
            }
        });

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // ========== Initialize ==========
        initThree();
        updateDisplay();
    </script>
</body>
</html>
