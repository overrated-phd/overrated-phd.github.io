<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN Digit Classifier</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            color: #e8e8e8;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 1.8rem;
            color: #00d9ff;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #888;
            font-size: 0.95rem;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Input Section */
        .input-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .draw-area {
            text-align: center;
        }

        .draw-area h3 {
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9rem;
        }

        #drawCanvas {
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            cursor: crosshair;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        .btn {
            padding: 8px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-clear {
            background: #ff6b6b;
            color: white;
        }

        .btn-classify {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            color: #1a1a2e;
            font-weight: bold;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        /* CNN Pipeline */
        .pipeline {
            background: rgba(255,255,255,0.03);
            border-radius: 15px;
            padding: 25px;
            overflow-x: auto;
        }

        .pipeline-scroll {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            min-width: max-content;
        }

        .layer {
            text-align: center;
            flex-shrink: 0;
        }

        .layer-name {
            font-size: 0.75rem;
            color: #00d9ff;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .layer-size {
            font-size: 0.65rem;
            color: #666;
            margin-bottom: 8px;
            font-family: monospace;
        }

        .feature-maps {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .feature-map {
            border-radius: 4px;
            image-rendering: pixelated;
        }

        .arrow {
            color: #00ff88;
            font-size: 1.5rem;
            align-self: center;
            padding-top: 30px;
        }

        /* Output */
        .output-section {
            text-align: center;
        }

        .predictions {
            display: flex;
            flex-direction: column;
            gap: 3px;
            align-items: center;
        }

        .pred-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            width: 80px;
        }

        .pred-digit {
            font-size: 0.75rem;
            font-weight: bold;
            color: #fff;
            width: 12px;
        }

        .pred-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .pred-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .pred-prob {
            font-size: 0.6rem;
            color: #888;
            width: 28px;
            text-align: right;
        }

        .pred-item.winner {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
        }

        .pred-item.winner .pred-digit {
            color: #00ff88;
        }

        /* RGB Channels */
        .rgb-channels {
            display: flex;
            gap: 3px;
        }

        .channel-box {
            text-align: center;
        }

        .channel-label {
            font-size: 0.6rem;
            margin-bottom: 2px;
        }

        .channel-label.r { color: #ff6b6b; }
        .channel-label.g { color: #51cf66; }
        .channel-label.b { color: #339af0; }

        @media (max-width: 600px) {
            .pipeline { padding: 15px; }
            .feature-map { transform: scale(0.8); }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>CNN Digit Classifier</h1>
            <p class="subtitle">Draw a digit (0-9) and watch how CNN processes it</p>
        </div>

        <div class="input-section">
            <div class="draw-area">
                <h3>Draw a digit here</h3>
                <canvas id="drawCanvas" width="150" height="150"></canvas>
                <div class="buttons">
                    <button class="btn btn-clear" onclick="clearCanvas()">Clear</button>
                    <button class="btn btn-classify" onclick="classify()">Classify →</button>
                </div>
            </div>
        </div>

        <div class="pipeline">
            <div class="pipeline-scroll" id="pipeline">
                <!-- Will be populated by JS -->
            </div>
        </div>
    </div>

    <script>
        // Drawing canvas setup
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        let isDrawing = false;

        drawCtx.fillStyle = '#000';
        drawCtx.fillRect(0, 0, 150, 150);
        drawCtx.strokeStyle = '#fff';
        drawCtx.lineWidth = 12;
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';

        drawCanvas.addEventListener('mousedown', startDraw);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', () => isDrawing = false);
        drawCanvas.addEventListener('mouseout', () => isDrawing = false);
        drawCanvas.addEventListener('touchstart', handleTouch);
        drawCanvas.addEventListener('touchmove', handleTouch);
        drawCanvas.addEventListener('touchend', () => isDrawing = false);

        function startDraw(e) {
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = drawCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawCtx.lineTo(x, y);
            drawCtx.stroke();
            drawCtx.beginPath();
            drawCtx.moveTo(x, y);
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = drawCanvas.getBoundingClientRect();
            if (e.type === 'touchstart') {
                isDrawing = true;
            }
            if (isDrawing) {
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
                drawCtx.beginPath();
                drawCtx.moveTo(x, y);
            }
        }

        function clearCanvas() {
            drawCtx.fillStyle = '#000';
            drawCtx.fillRect(0, 0, 150, 150);
            drawCtx.beginPath();
            initPipeline();
        }

        // Simulate CNN processing
        function classify() {
            // Get input image data
            const inputData = drawCtx.getImageData(0, 0, 150, 150);
            
            // Resize to 28x28 for processing
            const input28 = resizeImage(inputData, 28);
            
            // Simulate CNN layers
            const conv1 = simulateConv(input28, 28, 4);  // 4 filters
            const relu1 = applyReLU(conv1);
            const pool1 = simulatePool(relu1, 14);       // 14x14
            
            const conv2 = simulateConv2(pool1, 14, 8);   // 8 filters
            const relu2 = applyReLU(conv2);
            const pool2 = simulatePool(relu2, 7);        // 7x7
            
            // Generate fake predictions based on drawing
            const predictions = generatePredictions(input28);
            
            // Render pipeline
            renderPipeline(input28, conv1, relu1, pool1, conv2, relu2, pool2, predictions);
        }

        function resizeImage(imageData, size) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = tempCanvas.height = 150;
            tempCanvas.getContext('2d').putImageData(imageData, 0, 0);
            
            ctx.drawImage(tempCanvas, 0, 0, size, size);
            return ctx.getImageData(0, 0, size, size);
        }

        function simulateConv(input, size, numFilters) {
            const filters = [];
            for (let f = 0; f < numFilters; f++) {
                const filter = new Float32Array(size * size);
                for (let i = 0; i < input.data.length; i += 4) {
                    const idx = i / 4;
                    const val = input.data[i] / 255;
                    // Different filter responses
                    const x = idx % size;
                    const y = Math.floor(idx / size);
                    let response = val;
                    if (f === 0) response = val * (x / size); // horizontal gradient
                    if (f === 1) response = val * (y / size); // vertical gradient
                    if (f === 2) response = val * ((x + y) / (size * 2)); // diagonal
                    if (f === 3) response = val * (1 - Math.abs(x - size/2) / (size/2)); // center
                    filter[idx] = response;
                }
                filters.push({ data: filter, size });
            }
            return filters;
        }

        function simulateConv2(pooled, size, numFilters) {
            const filters = [];
            for (let f = 0; f < numFilters; f++) {
                const filter = new Float32Array(size * size);
                // Combine features from previous layer
                const srcFilter = pooled[f % pooled.length];
                for (let i = 0; i < size * size; i++) {
                    let val = srcFilter.data[i] || 0;
                    // Add some variation
                    val = val * (0.5 + Math.random() * 0.5);
                    filter[i] = Math.min(1, val);
                }
                filters.push({ data: filter, size });
            }
            return filters;
        }

        function applyReLU(filters) {
            return filters.map(f => ({
                data: f.data.map(v => Math.max(0, v)),
                size: f.size
            }));
        }

        function simulatePool(filters, newSize) {
            return filters.map(f => {
                const pooled = new Float32Array(newSize * newSize);
                const scale = f.size / newSize;
                for (let y = 0; y < newSize; y++) {
                    for (let x = 0; x < newSize; x++) {
                        let maxVal = 0;
                        for (let dy = 0; dy < scale; dy++) {
                            for (let dx = 0; dx < scale; dx++) {
                                const srcX = Math.floor(x * scale + dx);
                                const srcY = Math.floor(y * scale + dy);
                                const idx = srcY * f.size + srcX;
                                maxVal = Math.max(maxVal, f.data[idx] || 0);
                            }
                        }
                        pooled[y * newSize + x] = maxVal;
                    }
                }
                return { data: pooled, size: newSize };
            });
        }

        function generatePredictions(input) {
            // Simple heuristic based on pixel distribution
            const preds = new Array(10).fill(0).map(() => Math.random() * 0.1);
            
            // Analyze drawing to bias prediction
            let totalWhite = 0;
            let centerX = 0, centerY = 0;
            for (let i = 0; i < input.data.length; i += 4) {
                const val = input.data[i] / 255;
                if (val > 0.5) {
                    totalWhite++;
                    const idx = i / 4;
                    centerX += idx % 28;
                    centerY += Math.floor(idx / 28);
                }
            }
            
            if (totalWhite > 0) {
                centerX /= totalWhite;
                centerY /= totalWhite;
                
                // Bias based on shape characteristics
                const density = totalWhite / (28 * 28);
                if (density < 0.1) preds[1] += 0.5;
                else if (density > 0.25) preds[0] += 0.4;
                else {
                    preds[Math.floor(Math.random() * 10)] += 0.6;
                }
            }
            
            // Normalize
            const sum = preds.reduce((a, b) => a + b, 0);
            return preds.map(p => p / sum);
        }

        function renderPipeline(input, conv1, relu1, pool1, conv2, relu2, pool2, predictions) {
            const pipeline = document.getElementById('pipeline');
            pipeline.innerHTML = '';

            // Input
            const inputLayer = createLayer('input', '28×28×1', [createCanvas(input, 28, 40)]);
            pipeline.appendChild(inputLayer);
            pipeline.appendChild(createArrow());

            // Conv1
            const conv1Canvases = conv1.slice(0, 4).map(f => createFilterCanvas(f, 35));
            pipeline.appendChild(createLayer('conv_1', '28×28×4', conv1Canvases));
            pipeline.appendChild(createArrow());

            // ReLU1
            const relu1Canvases = relu1.slice(0, 4).map(f => createFilterCanvas(f, 35));
            pipeline.appendChild(createLayer('relu_1', '28×28×4', relu1Canvases));
            pipeline.appendChild(createArrow());

            // Pool1
            const pool1Canvases = pool1.slice(0, 4).map(f => createFilterCanvas(f, 30));
            pipeline.appendChild(createLayer('maxpool_1', '14×14×4', pool1Canvases));
            pipeline.appendChild(createArrow());

            // Conv2
            const conv2Canvases = conv2.slice(0, 8).map(f => createFilterCanvas(f, 25));
            pipeline.appendChild(createLayer('conv_2', '14×14×8', conv2Canvases));
            pipeline.appendChild(createArrow());

            // ReLU2
            const relu2Canvases = relu2.slice(0, 8).map(f => createFilterCanvas(f, 25));
            pipeline.appendChild(createLayer('relu_2', '14×14×8', relu2Canvases));
            pipeline.appendChild(createArrow());

            // Pool2
            const pool2Canvases = pool2.slice(0, 8).map(f => createFilterCanvas(f, 22));
            pipeline.appendChild(createLayer('maxpool_2', '7×7×8', pool2Canvases));
            pipeline.appendChild(createArrow());

            // Output
            pipeline.appendChild(createOutputLayer(predictions));
        }

        function createLayer(name, size, canvases) {
            const layer = document.createElement('div');
            layer.className = 'layer';
            layer.innerHTML = `
                <div class="layer-name">${name}</div>
                <div class="layer-size">${size}</div>
                <div class="feature-maps"></div>
            `;
            const maps = layer.querySelector('.feature-maps');
            canvases.forEach(c => maps.appendChild(c));
            return layer;
        }

        function createCanvas(imageData, size, displaySize) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            canvas.className = 'feature-map';
            canvas.style.width = canvas.style.height = displaySize + 'px';
            canvas.style.border = '1px solid #333';
            const ctx = canvas.getContext('2d');
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        function createFilterCanvas(filter, displaySize) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = filter.size;
            canvas.className = 'feature-map';
            canvas.style.width = canvas.style.height = displaySize + 'px';
            canvas.style.border = '1px solid #333';
            
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(filter.size, filter.size);
            
            for (let i = 0; i < filter.data.length; i++) {
                const val = Math.floor(filter.data[i] * 255);
                imgData.data[i * 4] = val;
                imgData.data[i * 4 + 1] = val;
                imgData.data[i * 4 + 2] = val;
                imgData.data[i * 4 + 3] = 255;
            }
            
            ctx.putImageData(imgData, 0, 0);
            return canvas;
        }

        function createArrow() {
            const arrow = document.createElement('div');
            arrow.className = 'arrow';
            arrow.textContent = '→';
            return arrow;
        }

        function createOutputLayer(predictions) {
            const layer = document.createElement('div');
            layer.className = 'layer';
            
            const maxIdx = predictions.indexOf(Math.max(...predictions));
            
            let html = `
                <div class="layer-name">output</div>
                <div class="layer-size">(10)</div>
                <div class="predictions">
            `;
            
            for (let i = 0; i < 10; i++) {
                const prob = (predictions[i] * 100).toFixed(0);
                const isWinner = i === maxIdx;
                html += `
                    <div class="pred-item ${isWinner ? 'winner' : ''}">
                        <div class="pred-digit">${i}</div>
                        <div class="pred-bar">
                            <div class="pred-fill" style="width: ${prob}%"></div>
                        </div>
                        <div class="pred-prob">${prob}%</div>
                    </div>
                `;
            }
            
            html += `</div>`;
            
            layer.innerHTML = html;
            return layer;
        }

        function initPipeline() {
            const pipeline = document.getElementById('pipeline');
            pipeline.innerHTML = `
                <div style="color: #666; padding: 40px; text-align: center; width: 100%;">
                    Draw a digit and click "Classify" to see the CNN pipeline
                </div>
            `;
        }

        initPipeline();
    </script>
</body>
</html>
